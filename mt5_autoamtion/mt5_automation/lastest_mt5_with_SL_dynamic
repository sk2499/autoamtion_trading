import MetaTrader5 as mt5
from flask import Flask, request, jsonify, render_template_string

app = Flask(__name__)

# MT5 Login Credentials
MT5_LOGIN = 190244904  # Replace with your MT5 account number
MT5_PASSWORD = "Qwerty@2"  # Replace with your MT5 password
MT5_SERVER = "Exness-MT5Trial14"  # Replace with your broker's server name
active_orders = {}  # Store active orders and metadata

# Map received symbols to MT5-compatible symbols
SYMBOL_MAP = {
    "NAS100": "USTECm",  # Map NAS100 to USTECm
    "BTCUSD": "BTCUSDm"
    # Add more mappings as needed
}

def map_symbol(webhook_symbol):
    """Convert TradingView symbol to MT5 symbol using the mapping."""
    return SYMBOL_MAP.get(webhook_symbol, webhook_symbol)  # Default to the same symbol if no mapping exists

# Initialize and login to MT5
def init_mt5():
    if not mt5.initialize():
        return "MT5 Initialization failed"

    authorized = mt5.login(MT5_LOGIN, password=MT5_PASSWORD, server=MT5_SERVER)
    if not authorized:
        return f"MT5 Login failed: {mt5.last_error()}"
    return "MT5 Login successful"


@app.route('/webhook', methods=['POST'])
def webhook():
    try:
        data = request.json

        if not data:
            print("Error: No JSON payload received")
            return jsonify({"status": "error", "message": "No JSON payload received"}), 400

        print("Received alert:", data)
        action = data['action'].lower()
        symbol = data.get('symbol',None)
        mt5_symbol = map_symbol(symbol)
        sl_value = float(data.get('sl_value', 0))
      #  price = float(data.get('price'))
      #  target_percentage = 0.0005  # .05

        # Calculate target price based on order type
        # if action == 'buy':
        #     tp = price * (1 + target_percentage)  # 2% above the price for buy
        # elif action == 'sell':
        #     tp = price * (1 - target_percentage)  # 2% below the price for sell


        if action in ['buy', 'sell']:
            # Handle buy or sell order
            try:
                price = float(data.get('price'))
            except ValueError:
                return jsonify({"status": "error", "message": "Invalid price format"}), 400

            if not action or not symbol or not price:
                print("Error: Missing required fields in payload")
                return jsonify({"status": "error", "message": "Missing fields in payload"}), 400

            # Place the MT5 order
            response = place_mt5_order(
                symbol=mt5_symbol,
                order_type=mt5.ORDER_TYPE_BUY if action == 'buy' else mt5.ORDER_TYPE_SELL,
                price=price,
                sl=sl_value,
                tp=None
            )

            if response["status"] == "success":
                order_ticket = response["order_ticket"]
                print('sl ticket')
                active_orders[mt5_symbol] = {"ticket": order_ticket, "symbol": mt5_symbol}# Store metadata
                print(active_orders)
                print(f"Order placed. Ticket: {order_ticket}, Active Orders: {active_orders}")
                return jsonify({"status": "success", "message": f"{action.capitalize()} order placed",
                                "order_ticket": order_ticket}), 200
            else:
                return jsonify({"status": "error", "message": response["message"]}), 500

        elif action == "update_sl":
            # # If symbol is not provided, attempt to infer it
            # order_ticket = data.get("order_ticket")
            # print('a')
            # print(order_ticket)# Assuming ticket is passed instead of symbol
            # if order_ticket:
            #     # Find the symbol by matching the ticket in active_orders
            #     mt5_symbol = next(
            #         (key for key, value in active_orders.items() if value["ticket"] == order_ticket),
            #         None
            #     )
            # else:
            #     mt5_symbol = None
            #
            # if not mt5_symbol:
            #     print("Error: Unable to determine symbol from alert or active orders")
            #     return jsonify({"error": "No symbol or matching ticket found"}), 404

            # Proceed with the rest of the update logic
            mt5_symbol = 'BTCUSDm'
            order_data = active_orders.get(mt5_symbol)
            if not order_data:
                print(f"No active order found for symbol: {mt5_symbol}")
                return jsonify({"error": "No active order found to update SL"}), 404

            order_ticket = order_data.get("ticket")
            print(f"Updating SL for ticket: {order_ticket}, Symbol: {mt5_symbol}")

            position = mt5.positions_get(ticket=order_ticket)
            if position:
                req = {
                    "action": mt5.TRADE_ACTION_SLTP,
                    "symbol": mt5_symbol,
                    "sl": sl_value,
                    "position": order_ticket,
                    "magic": 234000,
                    "comment": "Updated Stop Loss",
                }
                result = mt5.order_send(req)
                print(f"SL Update Result: {result}")
                if result.retcode == mt5.TRADE_RETCODE_DONE:
                    return jsonify({"message": "Stop loss updated", "order_ticket": order_ticket}), 200
                else:
                    return jsonify({"error": "Failed to update stop loss", "details": result}), 500
            else:
                return jsonify({"error": "Position not found for update_sl"}), 404

    except Exception as e:
        print(f"Error processing webhook: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500


def place_mt5_order(symbol, order_type, price, sl=None, tp=None):
    """Place an order in MT5."""
    login_status = init_mt5()
    if "failed" in login_status:
        print(login_status)
        return {"status": "error", "message": login_status}

    if not mt5.symbol_select(symbol, True):
        print(f"Symbol {symbol} not found")
        return {"status": "error", "message": f"Symbol {symbol} not found"}

    tick = mt5.symbol_info_tick(symbol)
    if not tick:
        print(f"Failed to get tick data for {symbol}")
        return {"status": "error", "message": f"Failed to get tick data for {symbol}"}

    request = {
        "action": mt5.TRADE_ACTION_DEAL,
        "symbol": symbol,
        "volume": 0.01,
        "type": order_type,
        "price": price,
        "sl": sl or 0.0,
        "tp": tp or 0.0,
        "deviation": 20,
        "magic": 234000,
        "comment": "TradingView Alert",
        "type_filling": mt5.ORDER_FILLING_IOC,
        "type_time": mt5.ORDER_TIME_GTC,
    }
    result = mt5.order_send(request)
    print(result)
    if result.retcode != mt5.TRADE_RETCODE_DONE:
        print(f"Order failed: {result}")
        return {"status": "error", "message": f"Order failed: {result.comment}"}
    else:
        print("Order placed successfully")
        return {"status": "success", "message": "Order placed successfully", "order_ticket": result.order}


@app.route('/login_balance', methods=['GET'])
def login_balance():
    """Login and fetch balance information."""
    login_status = init_mt5()

    if "failed" in login_status:
        return f"<h1>{login_status}</h1>"

    account_info = mt5.account_info()
    if account_info is None:
        return "<h1>Login failed, check credentials</h1>"

    return render_template_string(
        """
        <h1>MT5 Account Balance</h1>
        <ul>
            <li>Account Name: {{ account_info.name }}</li>
            <li>Account Balance: {{ account_info.balance }}</li>
            <li>Account Equity: {{ account_info.equity }}</li>
            <li>Account Currency: {{ account_info.currency }}</li>
        </ul>
        """,
        account_info=account_info
    )


if __name__ == '__main__':
    app.run(port=5000, debug=True)
