import MetaTrader5 as mt5
from flask import Flask, request, jsonify, render_template_string


app = Flask(__name__)

# MT5 Login Credentials
MT5_LOGIN = 190244904  # Replace with your MT5 account number
MT5_PASSWORD = "Qwerty@2"  # Replace with your MT5 password
MT5_SERVER = "Exness-MT5Trial14"  # Replace with your broker's server name
active_orders = {}

# Map received symbols to MT5-compatible symbols
SYMBOL_MAP = {
    "NAS100": "USTECm",  # Map NAS100 to USTECm
    "BTCUSD": "BTCUSDm"
    # Add more mappings as needed
}

def map_symbol(webhook_symbol):
    """Convert TradingView symbol to MT5 symbol using the mapping."""
    return SYMBOL_MAP.get(webhook_symbol, webhook_symbol)  # Default to the same symbol if no mapping exists

# Initialize and login to MT5
def init_mt5():
    if not mt5.initialize():
        return "MT5 Initialization failed"

    authorized = mt5.login(MT5_LOGIN, password=MT5_PASSWORD, server=MT5_SERVER)
    if not authorized:
        return f"MT5 Login failed: {mt5.last_error()}"
    return "MT5 Login successful"


@app.route('/webhook', methods=['POST'])
def webhook():
    try:
        data = request.json

        if not data:
            print("Error: No JSON payload received")
            return jsonify({"status": "error", "message": "No JSON payload received"}), 400

        print("Received alert:", data)
        symbol = data['symbol']
        mt5_symbol = map_symbol(symbol)
        sl_value = float(data.get('sl_value', 0))
        action = data['action'].lower()

        if action == 'buy' or action == 'sell':


            try:
                price = float(data['price'])
            except ValueError:
                return jsonify({"status": "error", "message": "Invalid price format"}), 400

            if not action or not symbol or not price:
                print("Error: Missing required fields in payload")
                return jsonify({"status": "error", "message": "Missing fields in payload"}), 400


            if action == 'buy':
                response = place_mt5_order(symbol=mt5_symbol, order_type=mt5.ORDER_TYPE_BUY, price=price,sl=sl_value,tp=None)
            elif action == 'sell':
                response = place_mt5_order(symbol=mt5_symbol, order_type=mt5.ORDER_TYPE_SELL, price=price,sl=sl_value,tp=None)
            else:
                print("Error: Invalid action")
                return jsonify({"status": "error", "message": "Invalid action"}), 400

            if response["status"] == "success":
                order_ticket = response["order_ticket"]
                active_orders[mt5_symbol] = order_ticket  # Store the order_ticket
                print(order_ticket)
                print(active_orders)
                return jsonify({"status": "success", "message": f"{action.capitalize()} order placed",
                                "order_ticket": order_ticket}), 200
            else:
                return jsonify({"status": "error", "message": response["message"]}), 500
            #print('1')
            # Return the response from the order placement
            # if response["status"] == "success":
            #     order_ticket = response["order_ticket"]  # Assuming you return the ticket from place_mt5_order
            #     new_stop_loss = float(data['stoploss'])  # Extract SL from the webhook payload
            #
            #     # Update the SL
            #     update_response = update_mt5_order_sl(order_ticket, new_stop_loss)
            #     if update_response["status"] == "success":
            #         return jsonify({"status": "success", "message": "Order placed and SL updated successfully"}), 200
            #     else:
            #         return jsonify({"status": "error", "message": update_response["message"]}), 500

            # if response.retcode == mt5.TRADE_RETCODE_DONE:
            #     order_ticket = response.order
            #     return jsonify({"message": "Initial order placed", "order_ticket": order_ticket})
            # else:
            #     return jsonify({"error": "Order placement failed", "details": response})


        elif action == "update_sl": #and order_ticket is not None:
            # Modify stop loss of the active order
            symbol = 'USTECm'
            order_ticket = active_orders.get(symbol)
            print(order_ticket)
            position = mt5.positions_get(ticket=order_ticket)
            if position:
                req = {
                    "action": mt5.TRADE_ACTION_SLTP,
                    "symbol": symbol,
                    "sl": sl_value,
                    "position": order_ticket,
                    "magic": 234000,
                    "comment": "Updated Stop Loss",
                }
                result = mt5.order_send(req)
                print(result)
                if result.retcode == mt5.TRADE_RETCODE_DONE:
                    return jsonify({"message": "Stop loss updated", "order_ticket": order_ticket})
                else:
                    return jsonify({"error": "Failed to update stop loss", "details": result})
            else:
                return jsonify({"error": "Order not found"})
        else:
            return jsonify({"error": "Invalid request or no active order"})

    except Exception as e:
        print(f"Error processing webhook: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500



def place_mt5_order(symbol, order_type, price, sl=None, tp=None):
    login_status = init_mt5()
    if "failed" in login_status:
        print(login_status)
        return {"status": "error", "message": login_status}

    if not mt5.symbol_select(symbol, True):
        print(f"Symbol {symbol} not found")
        return {"status": "error", "message": f"Symbol {symbol} not found"}

    tick = mt5.symbol_info_tick(symbol)
    if not tick:
        print(f"Failed to get tick data for {symbol}")
        return {"status": "error", "message": f"Failed to get tick data for {symbol}"}

    #price = tick.ask if order_type == mt5.ORDER_TYPE_BUY else tick.bid

    request = {
        "action": mt5.TRADE_ACTION_DEAL,
        "symbol": symbol,
        "volume": 0.1,
        "type": order_type,
        "price": price,
        "sl": sl or 0.0,
        "tp": tp or 0.0,
        "deviation": 20,
        "magic": 234000,
        "comment": "TradingView Alert",
        "type_filling": mt5.ORDER_FILLING_IOC,
        "type_time": mt5.ORDER_TIME_GTC,
    }
    result = mt5.order_send(request)
    print(result)
    if result.retcode != mt5.TRADE_RETCODE_DONE:
        print(f"Order failed: {result}")
        return {"status": "error", "message": f"Order failed: {result.comment}"}
    else:
        print("Order placed successfully")
        return {"status": "success", "message": "Order placed successfully", "order_ticket": result.order}


# def update_mt5_order_sl(order_ticket, new_sl):
#     request = {
#         "action": mt5.TRADE_ACTION_SLTP,
#         "position": order_ticket,
#         "sl": new_sl,
#     }
#     result = mt5.order_send(request)
#
#     if result.retcode == mt5.TRADE_RETCODE_DONE:
#         print(f"SL updated for order {order_ticket}")
#         return {"status": "success", "message": "Stop Loss updated successfully"}
#     else:
#         print(f"Failed to update SL for order {order_ticket}, Error: {result.comment}")
#         return {"status": "error", "message": f"Failed to update SL: {result.comment}"}

# New Route for Logging in and Fetching Balance
@app.route('/login_balance', methods=['GET'])
def login_balance():
    login_status = init_mt5()

    if "failed" in login_status:
        return f"<h1>{login_status}</h1>"

    account_info = mt5.account_info()
    if account_info is None:
        return "<h1>Login failed, check credentials</h1>"

    # Render the account balance
    return render_template_string(
        """
        <h1>MT5 Account Balance</h1>
        <ul>
            <li>Account Name: {{ account_info.name }}</li>
            <li>Account Balance: {{ account_info.balance }}</li>
            <li>Account Equity: {{ account_info.equity }}</li>
            <li>Account Currency: {{ account_info.currency }}</li>
        </ul>
        """,
        account_info=account_info
    )

if __name__ == '__main__':
    app.run(port=5000, debug=True)
